package org.geeksforgeeks.detectphysicalshake

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.widget.Toast
import java.util.*
import kotlin.math.sqrt


    internal inner class CustomInfoWindowAdapter : GoogleMap.InfoWindowAdapter {

        private val window: View = layoutInflater.inflate(R.layout.custom_info_contents, null)

        override fun getInfoWindow(marker: Marker): View? {
            render(markers!!, window)
            return window
        }

        override fun getInfoContents(marker: Marker): View? {
            render(markers!!, window)
            return window
        }

        private fun render(marker: Marker, view: View) {

            // Set the title and snippet for the custom info window

            val titleUi = view.findViewById<TextView>(R.id.title)
            if (marker.title != "") {
                titleUi.text = marker.title
            }

            val snippet: String? = marker.snippet
            val snippetUi = view.findViewById<TextView>(R.id.snippet)

            if (marker.snippet != "") {
                snippetUi.text = marker.snippet
            }

            snippetUi.text = snippet

        }
    }

      //googleMap.setOnCircleClickListener(onClickingPoint)
        // googleMap.setOnMapLongClickListener(onLongMapPress)

//    private val onLongMapPress = GoogleMap.OnMapLongClickListener {
//        if (polyLines.size == 0)
//            return@OnMapLongClickListener // Not yet...
//
//        map?.addMarker(MarkerOptions().title("Landing").position(it)
//
//        )
//
//
//        val loc = S2Helper.makeS2PointFromLngLat(it) // Get the point
//        val p = S2Helper.findClosestLine(linesIndex, it, polyLines)
//        Log.d("closest", "Closest l" +
//                "ine found, will look for closest point!")
//        if (p != null) {
//            (p as Polyline).color = Color.CYAN // change its colour..
//        }
//
//        val xloc = S2Helper.findClosestPointOnLine(pointsIndex, it) as S2LatLng?
//        if (xloc != null) {
//            val pt = LatLng(xloc.latDegrees(), xloc.lngDegrees())
//            // Draw the point on the line...
//            map?.addCircle(
//                CircleOptions().center(pt).fillColor(Color.CYAN).radius(0.5)
//                    .strokeWidth(1.0f)
//
//            )
//
//            Log.d("closest", "Closest point drawn")
//        }
//    }


class MainActivity : AppCompatActivity() {

	// Declaring sensorManager
	// and acceleration constants
	private var sensorManager: SensorManager? = null
	private var acceleration = 0f
	private var currentAcceleration = 0f
	private var lastAcceleration = 0f

	override fun onCreate(savedInstanceState: Bundle?) {
		super.onCreate(savedInstanceState)
		setContentView(R.layout.activity_main)

		// Getting the Sensor Manager instance
		sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager

		Objects.requireNonNull(sensorManager)!!
			.registerListener(sensorListener, sensorManager!!
			.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL)

		acceleration = 10f
		currentAcceleration = SensorManager.GRAVITY_EARTH
		lastAcceleration = SensorManager.GRAVITY_EARTH
	}

	private val sensorListener: SensorEventListener = object : SensorEventListener {
		override fun onSensorChanged(event: SensorEvent) {
			
			// Fetching x,y,z values
			val x = event.values[0]
			val y = event.values[1]
			val z = event.values[2]
			lastAcceleration = currentAcceleration
			
			// Getting current accelerations
			// with the help of fetched x,y,z values
			currentAcceleration = sqrt((x * x + y * y + z * z).toDouble()).toFloat()
			val delta: Float = currentAcceleration - lastAcceleration
			acceleration = acceleration * 0.9f + delta
			
			// Display a Toast message if
			// acceleration value is over 12
			if (acceleration > 12) {
				Toast.makeText(applicationContext, "Shake event detected", Toast.LENGTH_SHORT).show()
			}
		}
		override fun onAccuracyChanged(sensor: Sensor, accuracy: Int) {}
	}

	override fun onResume() {
		sensorManager?.registerListener(sensorListener, sensorManager!!.getDefaultSensor(
			Sensor .TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL
		)
		super.onResume()
	}

	override fun onPause() {
		sensorManager!!.unregisterListener(sensorListener)
		super.onPause()
	}
}
